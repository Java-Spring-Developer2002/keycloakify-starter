{"version":3,"file":"static/js/2185.0df82852.chunk.js","mappings":"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","sources":["../node_modules/evt/src/lib/Evt.asNonPostable.ts","../node_modules/evt/src/lib/Evt.asPostable.ts","../node_modules/evt/src/lib/Evt.asyncPipe.ts","../node_modules/evt/src/lib/Evt.create.ts","../node_modules/evt/src/lib/Evt.factorize.ts","../node_modules/evt/src/lib/Evt.from.ts","../node_modules/evt/src/lib/Evt.getCtx.ts","../node_modules/evt/src/lib/Evt.ts","../node_modules/evt/src/lib/Evt.loosenType.ts","../node_modules/evt/src/lib/Evt.merge.ts","../node_modules/evt/src/lib/Evt.newCtx.ts","../node_modules/evt/src/lib/Evt.parsePropsFromArgs.ts","../node_modules/evt/src/lib/LazyEvt.ts","../node_modules/evt/src/lib/importProxy.ts","../node_modules/evt/src/lib/types/EventTargetLike.ts","../node_modules/evt/src/lib/types/EvtError.ts","../node_modules/evt/src/lib/types/interfaces/CtxLike.ts","../node_modules/evt/src/lib/util/compose.ts","../node_modules/evt/src/lib/util/convertOperatorToStatelessFLambda.ts","../node_modules/evt/node_modules/tsafe/src/assert.ts","../node_modules/evt/node_modules/tsafe/src/id.ts","../node_modules/evt/node_modules/tsafe/src/is.ts","../node_modules/evt/node_modules/tsafe/src/isPromiseLike.ts","../node_modules/evt/node_modules/tsafe/src/lab/overwriteReadonlyProp.ts","../node_modules/evt/node_modules/tsafe/src/typeGuard.ts","../node_modules/evt/node_modules/tsafe/src/zz_internal/assertIsRefWrapper.ts","../node_modules/evt/src/tools/Deferred.ts","../node_modules/evt/src/tools/safeSetTimeout.ts","../node_modules/run-exclusive/src/lib/runExclusive.ts","../node_modules/run-exclusive/node_modules/minimal-polyfills/src/Map.ts","../node_modules/run-exclusive/node_modules/minimal-polyfills/src/WeakMap.ts"],"sourcesContent":["\nimport type { ToNonPostableEvt, NonPostableEvtLike } from \"./types\";\n\n/** https://docs.evt.land/api/evt/asnonpostable */\nexport function asNonPostable<E extends NonPostableEvtLike<any>>(evt: E): ToNonPostableEvt<E>{\n    return evt as any;\n}","import type { NonPostableEvtLike, ToPostableEvt } from \"./types\";\n\n/** \n * @deprecated: ⚠ UNSAFE ⚠ - Please don't use it, it will be removed in the next \n * major release.\n * https://docs.evt.land/api/evt/aspostable \n * */\nexport function asPostable<E extends NonPostableEvtLike<any>>(evt: E): ToPostableEvt<E>{\n    return evt as any;\n}\n\n","\nimport type { Evt } from \"./Evt\";\nimport type { StatefulEvt, UnpackEvt, NonPostableEvtLike, StatefulReadonlyEvtLike } from \"./types\";\nimport type { PromiseOrNot } from \"tsafe/lab/PromiseOrNot\";\nimport { importProxy } from \"./importProxy\";\n\n\n\n/** \n * NOTE: Workaround until v2.0 where .pipe() will support async operators \n * Usage example: https://stackblitz.com/edit/evt-async-op?file=index.ts \n * \n * When the argument is a StatefulEvt:\n * If, wile asyncOp was running, the state of the source evt\n * have changed then the result will be discarded.\n * \n * If the asyncOp complete synchronously (meaning it does not return\n * a promise) then the result is synchronously transformed. (As with .pipe() )\n * \n * More usage example in src/test/test95.ts\n */\nexport function asyncPipe<E extends NonPostableEvtLike<any>, U>(\n    evt: E,\n    asyncOp: (data: UnpackEvt<E>) => PromiseOrNot<[U] | null>\n): \n    E extends StatefulReadonlyEvtLike<any> ? StatefulEvt<U | undefined> : Evt<U> \n{\n\n    const out = \"state\" in evt ?\n        importProxy.Evt.create<UnpackEvt<E> | undefined>(undefined) :\n        importProxy.Evt.create<UnpackEvt<E>>();\n\n    let currentCallCount = 0;\n\n    evt.attach(async (data: UnpackEvt<E>) => {\n\n        currentCallCount++;\n\n        const thisCallCount = currentCallCount;\n\n        const prOpResult = asyncOp(data);\n\n        let opResult: [U] | null;\n\n        if (\n            prOpResult !== null &&\n            \"then\" in prOpResult\n        ) {\n\n            opResult = await prOpResult;\n\n            if (\n                \"state\" in evt &&\n                thisCallCount !== currentCallCount\n            ) {\n                return;\n            }\n\n        } else {\n\n            opResult = prOpResult;\n\n        }\n\n        if (!opResult) {\n\n            return;\n        }\n\n        out.post(opResult[0] as any);\n\n    });\n\n    return out as any;\n\n}\n\n","\nimport { importProxy } from \"./importProxy\";\nimport type { Evt, StatefulEvt, NonPostableEvtLike, UnpackEvt } from \"./types\";\n\nexport function create<E extends NonPostableEvtLike<any> | undefined = NonPostableEvtLike<void>>(): Evt<UnpackEvt<E>>;\n/** \n * https://docs.evt.land/api/evt/create\n * Return a new Evt<T> instance.\n */\nexport function create<T>(): Evt<T>;\n/** \n * https://docs.evt.land/api/evt/create\n * Return a new StatefulEvt<T> instance.\n */\nexport function create<T>(initialState: T ): StatefulEvt<T>;\nexport function create<E extends NonPostableEvtLike<any> | undefined>(initialState: UnpackEvt<E> ): StatefulEvt<UnpackEvt<E>>;\nexport function create(...args: [] | [any] ): Evt<any> | StatefulEvt<any> {\n    return args.length === 0 ? \n        new importProxy.Evt() : \n        new importProxy.StatefulEvt(args[0])\n        ;\n}","import type { FactorizeEvt, NonPostableEvtLike } from \"./types\";\n\n/** https://docs.evt.land/api/evt/factorize */\nexport function factorize<E extends NonPostableEvtLike<any>>(\n    evt: E\n): FactorizeEvt<E> {\n    return evt as any;\n}\n\n/*\nimport { Evt } from \"./Evt\";\nconst x: Evt<boolean> = loosenType(new Evt<true>()); x;\nconst y: Evt<boolean> = loosenType(new Evt<number>()); y;\n*/","import { id } from \"tsafe/id\";\nimport { assert } from \"tsafe/assert\";;\nimport { typeGuard } from \"tsafe/typeGuard\";\nimport { mergeImpl } from \"./Evt.merge\";\nimport { importProxy } from \"./importProxy\";\nimport type { dom, Evt, NonPostableEvtLike } from \"./types\";\nimport type { EventTargetLike } from \"./types\";\nimport * as nsEventTargetLike from \"./types/EventTargetLike\";\nconst { EventTargetLike: EventTargetLikeAsValue } = nsEventTargetLike;\nimport type { ObserverConstructor } from \"./types/Observer\";\n\ntype OneOrMany<T> = T | ArrayLike<T>;\ntype CtxLike<Result> = import(\"./types\").CtxLike<Result> & {\n    evtDoneOrAborted: NonPostableEvtLike<unknown> & { postCount: number; attachOnce(callback: () => void): void; };\n};\n\nfunction fromImplForTargetEventLike<T>(\n    ctx: CtxLike<any> | undefined,\n    target: OneOrMany<EventTargetLike<T>> | PromiseLike<T>,\n    eventName?: string,\n    options?: EventTargetLike.HasEventTargetAddRemove.Options\n): Evt<T> {\n\n    const matchEventTargetLike =\n        (target_: typeof target): target_ is EventTargetLike<T> =>\n            EventTargetLikeAsValue.canBe(target_);\n\n    if (!matchEventTargetLike(target)) {\n\n        if (\"then\" in target) {\n\n            const evt = new importProxy.Evt<T>();\n\n            const isCtxDone = (() => {\n\n                const getEvtDonePostCount = () => ctx?.evtDoneOrAborted.postCount;\n\n                const n = getEvtDonePostCount();\n\n                return () => n !== getEvtDonePostCount();\n\n            })();\n\n            target.then(data => {\n\n                if (isCtxDone()) {\n                    return;\n                }\n\n                evt.post(data);\n\n            });\n\n            return evt;\n\n        }\n\n        return mergeImpl<Evt<T>>(\n            ctx,\n            Array.from(target).map(\n                target => fromImplForTargetEventLike<T>(ctx, target, eventName, options)\n            )\n        );\n\n    }\n\n    type ProxyMethod<T> = (\n        listener: (data: T) => void,\n        eventName: string,\n        options?: EventTargetLike.HasEventTargetAddRemove.Options\n    ) => void;\n\n    let proxy: {\n        on: ProxyMethod<T>;\n        off: ProxyMethod<T>;\n    };\n\n    if (EventTargetLikeAsValue.HasEventTargetAddRemove.match(target)) {\n        proxy = {\n            \"on\": (listener, eventName, options) => target.addEventListener(eventName, listener, options),\n            \"off\": (listener, eventName, options) => target.removeEventListener(eventName, listener, options)\n        };\n    } else if (EventTargetLikeAsValue.NodeStyleEventEmitter.match(target)) {\n        proxy = {\n            \"on\": (listener, eventName) => target.addListener(eventName, listener),\n            \"off\": (listener, eventName) => target.removeListener(eventName, listener)\n        };\n    } else if (EventTargetLikeAsValue.JQueryStyleEventEmitter.match(target)) {\n        proxy = {\n            \"on\": (listener, eventName) => target.on(eventName, listener),\n            \"off\": (listener, eventName) => target.off(eventName, listener)\n        };\n    } else if (EventTargetLikeAsValue.RxJSSubject.match(target)) {\n\n        let subscription: EventTargetLike.RxJSSubject.Subscription;\n\n        proxy = {\n            \"on\": listener => subscription = target.subscribe(data => listener(data)),\n            \"off\": () => subscription.unsubscribe()\n        };\n\n    } else {\n\n        id<never>(target);\n        assert(false);\n\n    }\n\n    const evt = new importProxy.Evt<T>();\n\n    const listener = (data: T) => evt.post(data);\n\n    ctx?.evtDoneOrAborted.attachOnce(\n        () => proxy.off(\n            listener,\n            eventName!,\n            options\n        )\n    );\n\n    proxy.on(listener, eventName!, options);\n\n    return evt;\n\n}\n\nfunction fromImplForObserver<Target, Entry>(\n    ctx: CtxLike<any> | undefined,\n    ObserverConstructor: ObserverConstructor<Target, Entry>,\n    target: Target\n): Evt<Entry> {\n\n    const evt = importProxy.Evt.create<Entry>();\n\n    const listener = ([entry]: Entry[]) => evt.post(entry);\n\n    const observer = new ObserverConstructor(listener);\n\n    observer.observe(target);\n\n    ctx?.evtDoneOrAborted.attachOnce(\n        () => observer.disconnect()\n    );\n\n    return evt;\n\n}\n\n/** https://docs.evt.land/api/evt/from */\nexport function from<K extends keyof dom.HTMLElementEventMap>(\n    ctx: CtxLike<any>,\n    target: EventTargetLike.HTMLElement,\n    eventName: K,\n    options?: EventTargetLike.HasEventTargetAddRemove.Options\n): Evt<dom.HTMLElementEventMap[K]>;\n\nexport function from<K extends keyof dom.WindowEventMap>(\n    ctx: CtxLike<any>,\n    target: EventTargetLike.Window,\n    eventName: K,\n    options?: EventTargetLike.HasEventTargetAddRemove.Options\n): Evt<dom.WindowEventMap[K]>;\n\nexport function from<K extends keyof dom.DocumentEventMap>(\n    ctx: CtxLike<any>,\n    target: EventTargetLike.Document,\n    eventName: K,\n    options?: EventTargetLike.HasEventTargetAddRemove.Options\n): Evt<dom.DocumentEventMap[K]>;\n\nexport function from<T>(\n    ctx: CtxLike<any>,\n    target: OneOrMany<\n        EventTargetLike.NodeStyleEventEmitter |\n        EventTargetLike.JQueryStyleEventEmitter\n    >,\n    eventName: string\n): Evt<T>;\nexport function from<T>(\n    ctx: CtxLike<any>,\n    target: OneOrMany<\n        EventTargetLike.HasEventTargetAddRemove<T>\n    >,\n    eventName: string,\n    options?: EventTargetLike.HasEventTargetAddRemove.Options\n): Evt<T>;\nexport function from<T>(\n    ctx: CtxLike<any>,\n    target: OneOrMany<EventTargetLike.RxJSSubject<T>>\n): Evt<T>;\n\nexport function from<T>(\n    ctx: CtxLike<any>,\n    target: PromiseLike<T>\n): Evt<T>;\n\nexport function from<Target, Entry>(\n    ctx: CtxLike<any>,\n    ObserverConstructor: ObserverConstructor<Target, Entry>,\n    target: Target\n): Evt<Entry>;\n\n\nexport function from<K extends keyof dom.HTMLElementEventMap>(\n    target: EventTargetLike.HTMLElement,\n    eventName: K,\n    options?: EventTargetLike.HasEventTargetAddRemove.Options\n): Evt<dom.HTMLElementEventMap[K]>;\nexport function from<K extends keyof dom.WindowEventMap>(\n    target: EventTargetLike.Window,\n    eventName: K,\n    options?: EventTargetLike.HasEventTargetAddRemove.Options\n): Evt<dom.WindowEventMap[K]>;\nexport function from<K extends keyof dom.DocumentEventMap>(\n    target: EventTargetLike.Document,\n    eventName: K,\n    options?: EventTargetLike.HasEventTargetAddRemove.Options\n): Evt<dom.DocumentEventMap[K]>;\nexport function from<T>(\n    target: OneOrMany<\n        EventTargetLike.NodeStyleEventEmitter |\n        EventTargetLike.JQueryStyleEventEmitter\n    >,\n    eventName: string\n): Evt<T>;\nexport function from<T>(\n    target: OneOrMany<\n        EventTargetLike.HasEventTargetAddRemove<T>\n    >,\n    eventName: string,\n    options?: EventTargetLike.HasEventTargetAddRemove.Options\n): Evt<T>;\nexport function from<T>(\n    target: OneOrMany<EventTargetLike.RxJSSubject<T>>\n): Evt<T>;\nexport function from<T>(\n    target: PromiseLike<T>\n): Evt<T>;\n\nexport function from<Target, Entry>(\n    ObserverConstructor: ObserverConstructor<Target, Entry>,\n    target: Target\n): Evt<Entry>;\n/*\n/^[A-Z]/.test(targetOrEventNameOrObserverConstructorOrObserverTarget.name\n    */\n\nexport function from<T, ObserverTarget = never>(\n    ctxOrTargetOrObserverConstructor: CtxLike<any> | OneOrMany<EventTargetLike<T>> | PromiseLike<T> | ObserverConstructor<ObserverTarget, T>,\n    targetOrEventNameOrObserverConstructorOrObserverTarget?: OneOrMany<EventTargetLike<T>> | string | PromiseLike<T> | ObserverConstructor<ObserverTarget, T> | ObserverTarget,\n    eventNameOrOptionsOrObserverTarget?: string | EventTargetLike.HasEventTargetAddRemove.Options | ObserverTarget,\n    options?: EventTargetLike.HasEventTargetAddRemove.Options\n): Evt<T> {\n\n    if (\"evtDoneOrAborted\" in ctxOrTargetOrObserverConstructor) {\n\n        assert(\n            typeGuard<OneOrMany<EventTargetLike<T>> | PromiseLike<T> | ObserverConstructor<ObserverTarget, T>>(targetOrEventNameOrObserverConstructorOrObserverTarget, true) &&\n            typeGuard<string | undefined | ObserverTarget>(eventNameOrOptionsOrObserverTarget, true) &&\n            typeGuard<EventTargetLike.HasEventTargetAddRemove.Options | undefined>(options, true)\n        );\n\n        if (typeof targetOrEventNameOrObserverConstructorOrObserverTarget === \"function\") {\n\n            assert(\n                typeGuard<ObserverTarget>(eventNameOrOptionsOrObserverTarget, true) &&\n                typeGuard<undefined>(options, true)\n            );\n\n            return fromImplForObserver(\n                ctxOrTargetOrObserverConstructor,\n                targetOrEventNameOrObserverConstructorOrObserverTarget,\n                eventNameOrOptionsOrObserverTarget\n            );\n\n        } else {\n\n            assert(\n                typeGuard<Exclude<typeof eventNameOrOptionsOrObserverTarget, ObserverTarget>>(eventNameOrOptionsOrObserverTarget, true)\n            );\n\n            return fromImplForTargetEventLike(\n                ctxOrTargetOrObserverConstructor,\n                targetOrEventNameOrObserverConstructorOrObserverTarget,\n                eventNameOrOptionsOrObserverTarget,\n                options\n            );\n\n        }\n\n\n    } else {\n\n        assert(\n            typeGuard<Exclude<typeof ctxOrTargetOrObserverConstructor, CtxLike<any>>>(ctxOrTargetOrObserverConstructor, true) &&\n            typeGuard<string | undefined | ObserverTarget>(targetOrEventNameOrObserverConstructorOrObserverTarget, true) &&\n            typeGuard<EventTargetLike.HasEventTargetAddRemove.Options | undefined>(eventNameOrOptionsOrObserverTarget, true)\n        );\n\n        if (typeof ctxOrTargetOrObserverConstructor === \"function\") {\n\n            assert(\n                typeGuard<ObserverTarget>(targetOrEventNameOrObserverConstructorOrObserverTarget, true) &&\n                typeGuard<undefined>(eventNameOrOptionsOrObserverTarget, true)\n            );\n\n            return fromImplForObserver(\n                undefined,\n                ctxOrTargetOrObserverConstructor,\n                targetOrEventNameOrObserverConstructorOrObserverTarget\n            );\n\n\n        } else {\n\n            assert(\n                typeGuard<Exclude<typeof targetOrEventNameOrObserverConstructorOrObserverTarget, ObserverTarget>>(\n                    targetOrEventNameOrObserverConstructorOrObserverTarget, true\n                )\n            );\n\n            return fromImplForTargetEventLike(\n                undefined,\n                ctxOrTargetOrObserverConstructor,\n                targetOrEventNameOrObserverConstructorOrObserverTarget,\n                eventNameOrOptionsOrObserverTarget\n            );\n\n        }\n\n\n\n    }\n\n}\n","import { Polyfill as WeakMap } from \"minimal-polyfills/WeakMap\";\nimport { importProxy } from \"./importProxy\";\nimport type { Ctx } from \"./types\";\n\n/** \n * https://docs.evt.land/api/evt/getctx\n * \n * Evt.getCtx(obj) an instance of Ctx<void>, always the same for a given object.\n * No strong reference to the object is created\n * when the object is no longer referenced it's associated Ctx will be freed from memory.\n */\nexport function getCtxFactory() {\n\n    const ctxByObj = new WeakMap<object, Ctx>();\n\n    function getCtx(obj: object): Ctx {\n\n        let ctx = ctxByObj.get(obj);\n\n        if (ctx === undefined) {\n\n            ctx = (new importProxy.Ctx());\n\n            ctxByObj.set(obj, ctx);\n\n        }\n\n        return ctx;\n\n    }\n\n    return getCtx;\n\n}\n","import \"minimal-polyfills/Array.prototype.find\";\nimport { importProxy } from \"./importProxy\";\nimport { create } from \"./Evt.create\";\nimport { getCtxFactory } from \"./Evt.getCtx\";\nimport { factorize } from \"./Evt.factorize\";\nimport { merge } from \"./Evt.merge\";\nimport { from } from \"./Evt.from\";\nimport { asPostable } from \"./Evt.asPostable\";\nimport { asyncPipe } from \"./Evt.asyncPipe\";\nimport { asNonPostable } from \"./Evt.asNonPostable\";\nimport { parsePropsFromArgs, matchAll } from \"./Evt.parsePropsFromArgs\";\nimport { newCtx } from \"./Evt.newCtx\";\nimport { LazyEvt } from \"./LazyEvt\";\nimport { Polyfill as Map, LightMap } from \"minimal-polyfills/Map\";\nimport { Polyfill as WeakMap } from \"minimal-polyfills/WeakMap\";\nimport * as runExclusive from \"run-exclusive\";\nimport { overwriteReadonlyProp } from \"tsafe/lab/overwriteReadonlyProp\";\nimport { typeGuard } from \"tsafe/typeGuard\";\nimport { Deferred } from \"../tools/Deferred\";\nimport { loosenType } from \"./Evt.loosenType\";\nimport { safeClearTimeout, safeSetTimeout, Timer } from \"../tools/safeSetTimeout\";\nimport { isPromiseLike } from \"tsafe/isPromiseLike\";\nimport { DetachedEvtError, TimeoutEvtError } from \"./types/EvtError\";\nimport * as nsCtxLike from \"./types/interfaces/CtxLike\";\nimport type { Handler, Operator, NonPostableEvt, StatefulEvt, NonPostableEvtLike, CtxLike } from \"./types\";\nimport { convertOperatorToStatelessFλ } from \"./util/convertOperatorToStatelessFLambda\";\nimport type { AsyncIterableEvt } from \"./types/AsyncIterableEvt\";\n\nconst runSideEffect = (sideEffect: () => void) => sideEffect();\n\n// NOTE: For compat with --no-check \n// https://github.com/asos-craigmorten/opine/issues/97#issuecomment-751806014\nconst { CtxLike: CtxLikeAsValue } = nsCtxLike;\n\n/** https://docs.evt.land/api/evt */\nexport type Evt<T> = import(\"./types/interfaces/Evt\").Evt<T>;\n\n\nclass EvtImpl<T> implements Evt<T> {\n\n    static readonly create = create;\n\n    static readonly newCtx = newCtx;\n\n    static readonly merge = merge;\n\n    static readonly from = from;\n\n    static readonly getCtx = getCtxFactory();\n\n    static readonly loosenType = loosenType;\n\n    static readonly factorize = factorize;\n\n    static readonly asPostable = asPostable;\n\n    static readonly asyncPipe = asyncPipe;\n\n    static readonly asNonPostable = asNonPostable;\n\n    private static __defaultMaxHandlers = 25;\n\n    static setDefaultMaxHandlers(n: number): void {\n        this.__defaultMaxHandlers = isFinite(n) ? n : 0;\n    }\n\n    toStateful(p1: any, p2?: CtxLike): StatefulEvt<any> {\n\n        const isP1Ctx = CtxLikeAsValue.match(p1);\n\n        const initialValue: any = isP1Ctx ? undefined : p1;\n        const ctx = p2 || (isP1Ctx ? p1 : undefined);\n\n        const out = new importProxy.StatefulEvt<any>(initialValue);\n\n        const callback = (data: T) => out.post(data);\n\n        if (!!ctx) {\n            this.attach(ctx, callback);\n        } else {\n            this.attach(callback);\n        }\n\n        return out;\n\n    }\n\n    get evtAttach(): Evt<Handler<T, any>> {\n        return this.lazyEvtAttach.evt;\n    }\n\n    get evtDetach(): Evt<Handler<T, any>> {\n        return this.lazyEvtDetach.evt;\n    }\n\n    private readonly lazyEvtAttach = new LazyEvt<Handler<T, any>>();\n    private readonly lazyEvtDetach = new LazyEvt<Handler<T, any>>();\n\n\n    private __maxHandlers: undefined | number = undefined;\n\n    setMaxHandlers(n: number): this {\n        this.__maxHandlers = isFinite(n) ? n : 0;\n        return this;\n    }\n\n    readonly postCount: number = 0;\n\n    private traceId: string | null = null;\n    private traceFormatter!: (data: T) => string;\n    private log!: Exclude<Parameters<NonPostableEvt<any>[\"enableTrace\"]>[0][\"log\"], false>;\n\n    enableTrace(\n        params: {\n            id: string,\n            formatter?: (data: T) => string,\n            log?: ((message?: any, ...optionalParams: any[]) => void) | false\n        }\n        //NOTE: Not typeof console.log as we don't want to expose types from node\n    ): void {\n\n        const { id, formatter, log } = params;\n\n        this.traceId = id;\n\n        this.traceFormatter = formatter || (\n            data => {\n                try {\n                    return JSON.stringify(data, null, 2);\n                } catch {\n                    return `${data}`;\n                }\n            }\n        );\n\n        this.log =\n            log === undefined ?\n                ((...inputs) => console.log(...inputs)) :\n                log === false ? undefined : log\n            ;\n\n    }\n\n    disableTrace(): this {\n        this.traceId = null;\n        return this;\n    }\n\n    private readonly handlers: Handler<T, any>[] = [];\n\n    private readonly handlerTriggers: LightMap<\n        Handler<T, any>,\n        (opResult: readonly [any]) => PromiseLike<void> | undefined\n    > = new Map();\n\n\n    //NOTE: An async handler ( attached with waitFor ) is only eligible to handle a post if the post\n    //occurred after the handler was set. We don't want to waitFor event from the past.\n    //private readonly asyncHandlerChronologyMark = new WeakMap<ImplicitParams.Async, number>();\n    private get asyncHandlerChronologyMark(): WeakMap<\n        Handler.PropsFromMethodName.Async,\n        number\n    > {\n        return ((this as any)[\"~internal\"] ??= {})[\"asyncHandlerChronologyMark\"] ??= new WeakMap<any, any>();\n    }\n\n    //NOTE: There is an exception to the above rule, we want to allow async waitFor loop \n    //do so we have to handle the case where multiple event would be posted synchronously.\n    private get asyncHandlerChronologyExceptionRange(): WeakMap<\n        Handler.PropsFromMethodName.Async,\n        { lowerMark: number; upperMark: number; }\n    > {\n        return ((this as any)[\"~internal\"] ??= {})[\"asyncHandlerChronologyExceptionRange\"] ??= new WeakMap<any, any>();\n    }\n\n\n    private get invocableOpByOp(): WeakMap<\n        Operator<T, any>,\n        Operator.fλ.Stateless<T, any>\n    > {\n        return ((this as any)[\"~internal\"] ??= {})[\"invocableOpByOp\"] ??= new WeakMap<any, any>();\n    }\n\n    getInvocableOp<U>(op: Operator<T, U>): Operator.fλ.Stateless<T, U> {\n\n        const invocableOp = this.invocableOpByOp.get(op);\n\n        if (invocableOp === undefined) {\n            throw new Error([\n                \"Provided operator isn't the operator of any handler\",\n                \"currently attached to the Evt instance\"\n            ].join(\" \"));\n        }\n\n        return invocableOp;\n\n    }\n\n    /*\n    NOTE: Used as Date.now() would be used to compare if an event is anterior \n    or posterior to an other. We don't use Date.now() because two call within\n    less than a ms will return the same value unlike this function.\n    */\n    private __currentChronologyMark = 0;\n    private getChronologyMark() {\n        return this.__currentChronologyMark++;\n    }\n\n\n    private asyncHandlerCount: number = 0;\n\n    private detachHandler(\n        handler: Handler<T, any>,\n        wTimer: [Timer | undefined],\n        rejectPr: (error: DetachedEvtError) => void\n    ) {\n\n        const index = this.handlers.indexOf(handler);\n\n        if (index < 0) {\n            return false;\n        }\n\n        if (typeGuard<Handler<T, any, CtxLike<any>>>(handler, !!handler.ctx)) {\n            handler.ctx.zz__removeHandler(handler);\n        }\n\n\n        this.handlers.splice(index, 1);\n\n        if (handler.async) {\n            this.asyncHandlerCount--;\n        }\n\n        this.handlerTriggers.delete(handler);\n\n        if (wTimer[0] !== undefined) {\n\n            safeClearTimeout(wTimer[0]);\n\n            rejectPr(new DetachedEvtError());\n\n        }\n\n        this.lazyEvtDetach.post(handler);\n\n        return true;\n\n    }\n\n\n    private triggerHandler<U>(\n        handler: Handler<T, U>,\n        wTimer: [Timer | undefined],\n        resolvePr: ((transformedData: any) => void) | undefined,\n        opResult: readonly [U] //TODO: Or readonly [ any ] ?? \n    ): PromiseLike<void> | undefined {\n\n        const { callback, once } = handler;\n\n        if (wTimer[0] !== undefined) {\n            safeClearTimeout(wTimer[0]);\n            wTimer[0] = undefined;\n        }\n\n        if (once) {\n            handler.detach();\n        }\n\n        const [transformedData] = opResult;\n\n        const prOrValue = callback?.call(\n            this,\n            transformedData\n        );\n\n        resolvePr?.(transformedData);\n\n        return isPromiseLike(prOrValue) ? prOrValue : undefined;\n\n    }\n\n    private addHandler<U>(\n        propsFromArgs: Handler.PropsFromArgs<T, U>,\n        propsFromMethodName: Handler.PropsFromMethodName\n    ): Handler<T, U> {\n\n        this.invocableOpByOp.set(\n            propsFromArgs.op,\n            convertOperatorToStatelessFλ(propsFromArgs.op)\n        );\n\n        const d = new Deferred<U>();\n\n        const wTimer: [Timer | undefined] = [undefined];\n\n        const handler: Handler<T, U> = {\n            ...propsFromArgs,\n            ...propsFromMethodName,\n            \"detach\": () => this.detachHandler(handler, wTimer, d.reject),\n            \"promise\": d.pr\n        };\n\n        if (typeof handler.timeout === \"number\") {\n\n            wTimer[0] = safeSetTimeout(() => {\n\n                wTimer[0] = undefined;\n\n                handler.detach();\n\n                d.reject(new TimeoutEvtError(handler.timeout!));\n\n            }, handler.timeout);\n\n        }\n\n        const handlerTrigger: (opResult: readonly [U]) => PromiseLike<void> | undefined\n            = opResult => this.triggerHandler(\n                handler,\n                wTimer,\n                d.isPending ? d.resolve : undefined,\n                opResult\n            );\n\n        this.handlerTriggers.set(\n            handler,\n            handlerTrigger\n        );\n\n        if (handler.async) {\n\n            this.asyncHandlerChronologyMark.set(\n                handler,\n                this.getChronologyMark()\n            );\n\n        }\n\n        if (handler.prepend) {\n\n            let i: number;\n\n            for (i = 0; i < this.handlers.length; i++) {\n\n                if (this.handlers[i].extract) {\n                    continue;\n                }\n\n                break;\n\n            }\n\n            this.handlers.splice(i, 0, handler);\n\n        } else {\n\n            this.handlers.push(handler);\n\n        }\n\n        if (handler.async) {\n            this.asyncHandlerCount++;\n        }\n\n        this.checkForPotentialMemoryLeak();\n\n        if (typeGuard<Handler<T, U, CtxLike<any>>>(handler, !!handler.ctx)) {\n            handler.ctx.zz__addHandler(handler, this);\n        }\n\n        onAddHandlerByEvt.get(this)?.(handler, handlerTrigger);\n\n        //NOTE: Can happen for example if this is a StatefulEvt \n        //and the handler is \"once\" and the matcher match the state \n        //We don't want to post an attach if the handler is already detached.\n        if (this.handlerTriggers.has(handler)) {\n\n            this.lazyEvtAttach.post(handler);\n\n        }\n\n        return handler;\n\n    }\n\n\n\n    private checkForPotentialMemoryLeak(): void {\n\n        const maxHandlers = this.__maxHandlers !== undefined ?\n            this.__maxHandlers :\n            EvtImpl.__defaultMaxHandlers\n            ;\n\n\n        if (\n            maxHandlers === 0 ||\n            this.handlers.length % (maxHandlers + 1) !== 0) {\n            return;\n        }\n\n        let message = [\n            `MaxHandlersExceededWarning: Possible Evt memory leak detected.`,\n            `${this.handlers.length} handlers attached${this.traceId ? ` to \"${this.traceId}\"` : \"\"}.\\n`,\n            `Use Evt.prototype.setMaxHandlers(n) to increase limit on a specific Evt.\\n`,\n            `Use Evt.setDefaultMaxHandlers(n) to change the default limit currently set to ${EvtImpl.__defaultMaxHandlers}.\\n`,\n        ].join(\"\");\n\n        const map = new Map<string, number>();\n\n        this.getHandlers()\n            .map(({ ctx, async, once, prepend, extract, op, callback }) => ({\n                \"hasCtx\": !!ctx,\n                once,\n                prepend,\n                extract,\n                \"isWaitFor\": async,\n                ...(op === matchAll ? {} : { \"op\": op.toString() }),\n                ...(!callback ? {} : { \"callback\": callback.toString() })\n            }))\n            .map(obj =>\n                \"{\\n\" + Object.keys(obj)\n                    .map(key => `  ${key}: ${(obj as any)[key]}`)\n                    .join(\",\\n\") + \"\\n}\"\n            )\n            .forEach(str => map.set(str, (map.has(str) ? map.get(str)! : 0) + 1))\n            ;\n\n        message += \"\\n\" + Array.from(map.keys())\n            .map(str => `${map.get(str)} handler${map.get(str) === 1 ? \"\" : \"s\"} like:\\n${str}`)\n            .join(\"\\n\") + \"\\n\";\n\n        if (this.traceId === null) {\n\n            message += \"\\n\" + [\n                `To validate the identify of the Evt instance that is triggering this warning you can call`,\n                `Evt.prototype.enableTrace({ \"id\": \"My evt id\", \"log\": false }) on the Evt that you suspect.\\n`\n            ].join(\" \");\n\n        }\n\n        try {\n            console.warn(message);\n        } catch {\n        }\n\n    }\n\n    isHandledByOp<U>(op: Operator<T, U>, data: T): boolean {\n\n        let hasSideEffect = false;\n\n        let invocableOp: Operator.fλ.Stateless<T, U>;\n\n        try {\n\n            invocableOp = this.getInvocableOp(op);\n\n        } catch {\n\n            return false;\n\n        }\n\n        const opResult = invocableOp(\n            data,\n            () => hasSideEffect = true\n        );\n\n        return opResult !== null || hasSideEffect;\n\n    }\n\n\n    private trace(data: T) {\n\n        if (this.traceId === null) {\n            return;\n        }\n\n        let message = `(${this.traceId}) `;\n\n        const isExtracted = !!this.handlers.find(\n            ({ extract, op }) => (\n                extract &&\n                this.isHandledByOp(op, data)\n            )\n        );\n\n        if (isExtracted) {\n\n            message += \"extracted \";\n\n        } else {\n\n            const handlerCount = this.handlers\n                .filter(\n                    ({ extract, op }) => !extract &&\n                        this.isHandledByOp(op, data)\n                )\n                .length;\n\n            message += `${handlerCount} handler${(handlerCount > 1) ? \"s\" : \"\"}, `;\n\n        }\n\n        this.log?.(message + this.traceFormatter(data));\n\n    }\n\n    /** Return [ isExtracted, prAllHandlerCallbacksResolved ] */\n    private postSync(data: T): readonly [boolean, Promise<void>] {\n\n        const prAllHandlerCallbacksResolved: PromiseLike<void>[] = [];\n\n        const getReturnValue = (isExtracted: boolean) => [\n            isExtracted,\n            Promise.all(prAllHandlerCallbacksResolved).then(() => { })\n        ] as const;\n\n\n        for (const handler of [...this.handlers]) {\n\n            const { async, op, extract } = handler;\n\n            if (async) {\n                continue;\n            }\n\n            //NOTE: If detached while executing the operator\n            //we still want to trigger the handler.\n            const handlerTrigger = this.handlerTriggers.get(handler);\n\n            const opResult = this.getInvocableOp(op)(\n                data,\n                runSideEffect\n            );\n\n            if (opResult === null) {\n                continue;\n            }\n\n            //NOTE: Possible if detached while in the loop.\n            if (!handlerTrigger) {\n                continue;\n            }\n\n            const prOrUndefined = handlerTrigger(opResult);\n\n            if (prOrUndefined !== undefined) {\n                prAllHandlerCallbacksResolved.push(prOrUndefined);\n            }\n\n            if (extract) {\n                return getReturnValue(true);\n            }\n\n        }\n\n        return getReturnValue(false);\n\n    }\n\n    private postAsyncFactory() {\n        return runExclusive.buildMethodCb(\n            (data: T, postChronologyMark: number, releaseLock?) => {\n\n                if (this.asyncHandlerCount === 0) {\n                    releaseLock();\n                    return;\n                }\n\n                const promises: Promise<void>[] = [];\n\n                let chronologyMarkStartResolveTick: number;\n\n                //NOTE: Must be before handlerTrigger call.\n                Promise.resolve().then(\n                    () => chronologyMarkStartResolveTick = this.getChronologyMark()\n                );\n\n\n                for (const handler of [...this.handlers]) {\n\n                    if (!handler.async) {\n                        continue;\n                    }\n\n                    const opResult = this.getInvocableOp(handler.op)(\n                        data,\n                        runSideEffect\n                    );\n\n                    if (opResult === null) {\n                        continue;\n                    }\n\n                    const handlerTrigger = this.handlerTriggers.get(handler);\n\n                    if (!handlerTrigger) {\n                        continue;\n                    }\n\n                    const shouldCallHandlerTrigger = (() => {\n\n                        const handlerMark = this.asyncHandlerChronologyMark.get(handler)!;\n\n                        if (postChronologyMark > handlerMark) {\n                            return true;\n                        }\n\n                        const exceptionRange = this.asyncHandlerChronologyExceptionRange.get(handler);\n\n                        return (\n                            exceptionRange !== undefined &&\n                            exceptionRange.lowerMark < postChronologyMark &&\n                            postChronologyMark < exceptionRange.upperMark &&\n                            handlerMark > exceptionRange.upperMark\n                        );\n\n                    })();\n\n                    if (!shouldCallHandlerTrigger) {\n                        continue;\n                    }\n\n                    promises.push(\n                        new Promise<void>(\n                            resolve => handler.promise\n                                .then(() => resolve())\n                                .catch(() => resolve())\n                        )\n                    );\n\n                    handlerTrigger(opResult);\n\n\n                }\n\n                if (promises.length === 0) {\n                    releaseLock();\n                    return;\n                }\n\n                const handlersDump = [...this.handlers];\n\n                Promise.all(promises).then(() => {\n\n                    for (const handler of this.handlers) {\n\n                        if (!handler.async) {\n                            continue;\n                        }\n\n                        if (handlersDump.indexOf(handler) >= 0) {\n                            continue;\n                        }\n\n                        this.asyncHandlerChronologyExceptionRange.set(\n                            handler,\n                            {\n                                \"lowerMark\": postChronologyMark,\n                                \"upperMark\": chronologyMarkStartResolveTick\n                            }\n                        );\n\n                    }\n\n                    releaseLock();\n\n                });\n\n            }\n        );\n    }\n\n    declare private postAsync: (\n        (\n            data: T,\n            postChronologyMark: number\n        ) => void\n    ) | undefined;\n\n    private static readonly propsFormMethodNames: Record<\n        \"waitFor\" | \"attach\" | \"attachExtract\" | \"attachPrepend\" | \"attachOnce\" |\n        \"attachOncePrepend\" | \"attachOnceExtract\"\n        ,\n        Handler.PropsFromMethodName\n    > = {\n            \"waitFor\": { \"async\": true, \"extract\": false, \"once\": true, \"prepend\": false },\n            \"attach\": { \"async\": false, \"extract\": false, \"once\": false, \"prepend\": false },\n            \"attachExtract\": { \"async\": false, \"extract\": true, \"once\": false, \"prepend\": true },\n            \"attachPrepend\": { \"async\": false, \"extract\": false, \"once\": false, \"prepend\": true },\n            \"attachOnce\": { \"async\": false, \"extract\": false, \"once\": true, \"prepend\": false },\n            \"attachOncePrepend\": { \"async\": false, \"extract\": false, \"once\": true, \"prepend\": true },\n            \"attachOnceExtract\": { \"async\": false, \"extract\": true, \"once\": true, \"prepend\": true }\n        };\n\n    isHandled(data: T): boolean {\n        return !!this.getHandlers()\n            .find(({ op }) => this.isHandledByOp(op, data))\n            ;\n    }\n\n    getHandlers(): Handler<T, any>[] {\n        return [...this.handlers];\n    }\n\n    detach(ctx?: CtxLike<any>): Handler<T, any, any>[] {\n\n        const detachedHandlers: Handler<T, any>[] = [];\n\n        for (const handler of this.getHandlers()) {\n\n            if (ctx !== undefined && handler.ctx !== ctx) {\n                continue;\n            }\n\n            const wasStillAttached = handler.detach();\n\n            //NOTE: It should not be possible.\n            if (!wasStillAttached) {\n                continue;\n            }\n\n            detachedHandlers.push(handler);\n\n        }\n\n        return detachedHandlers;\n\n    }\n\n    pipe(...args: any[]): Evt<any> {\n\n        const evtDelegate = new EvtImpl<any>();\n\n        this.addHandler(\n            {\n                ...parsePropsFromArgs<T>(args, \"pipe\"),\n                \"callback\": (transformedData: any) => evtDelegate.post(transformedData)\n            },\n            EvtImpl.propsFormMethodNames.attach\n        );\n\n        return evtDelegate;\n\n    }\n\n    waitFor(...args: any[]): Promise<any> {\n        return this.addHandler(\n            parsePropsFromArgs<T>(args, \"waitFor\"),\n            EvtImpl.propsFormMethodNames.waitFor\n        ).promise;\n    }\n\n    [Symbol.asyncIterator]() {\n        return this.iter()[Symbol.asyncIterator]();\n    }\n\n    iter(...args: any[]): AsyncIterableEvt<any, any> {\n\n        const props = parsePropsFromArgs<T>(args, \"waitFor\");\n\n        const ctx = (props.ctx ?? newCtx()) as ReturnType<typeof newCtx>;\n\n        const self = this;\n\n        return {\n            ctx,\n            [Symbol.asyncIterator]() {\n\n                const previousDonePostCount = ctx.evtDoneOrAborted.postCount;\n\n                const timerWrap = (() => {\n\n                    const { timeout } = props;\n\n                    if (timeout === undefined) {\n                        return undefined;\n                    }\n\n                    const setTimeoutCallback = () => {\n                        const error = new TimeoutEvtError(timeout);\n                        ctx.abort(error);\n                    };\n\n                    const timer = setTimeout(setTimeoutCallback, timeout);\n\n                    return { timeout, setTimeoutCallback, timer };\n\n                })();\n\n                const evtProxy = self\n                    .pipe(ctx, props.op)\n                    .pipe((data, registerSideEffect) => {\n\n                        if (timerWrap !== undefined) {\n\n                            registerSideEffect(() => {\n\n                                clearTimeout(timerWrap.timer);\n\n                                timerWrap.timer = setTimeout(timerWrap.setTimeoutCallback, timerWrap.timeout);\n                            });\n\n                        }\n\n                        return [data];\n                    });\n\n                const events: [T][] = [];\n\n                evtProxy.attach(event => events.push([event]));\n\n                if (timerWrap !== undefined) {\n\n                    const { timer } = timerWrap;\n\n                    ctx.evtDoneOrAborted.attachOnce(\n                        event => event.type === \"DONE\",\n                        () => clearTimeout(timer)\n                    );\n\n                }\n\n                return {\n                    async next() {\n\n                        let eventWrap = events.shift();\n\n                        if (eventWrap === undefined) {\n\n                            const dEventWrap = new Deferred<[T] | undefined>();\n\n                            if (previousDonePostCount < ctx.evtDoneOrAborted.postCount) {\n                                return { \"done\": true };\n                            }\n\n                            const ctx2 = newCtx();\n\n                            ctx.evtDoneOrAborted.attachOnce(\n                                ctx2,\n                                () => dEventWrap.resolve(undefined)\n                            );\n\n                            evtProxy.attachOnceExtract(ctx2, event => {\n                                ctx2.done();\n                                dEventWrap.resolve([event])\n                            });\n\n                            eventWrap = await dEventWrap.pr;\n\n                            if (eventWrap === undefined) {\n                                return { \"done\": true };\n                            }\n\n                        }\n\n                        const out = { \"done\": false, \"value\": eventWrap[0] } as any;\n\n                        return out;\n\n                    },\n                    return() {\n\n                        self.detach(ctx);\n\n                        return { \"done\": true } as any;\n                    },\n                };\n            }\n\n        };\n\n\n    }\n\n\n\n\n    $attach(...args: any[]) {\n        return this.attach(...args);\n    }\n\n    attach(...args: any[]) {\n        return this.__attachX(args, \"attach\");\n    }\n\n    $attachOnce(...args: any[]) {\n        return this.attachOnce(...args);\n    }\n\n    attachOnce(...args: any[]) {\n        return this.__attachX(args, \"attachOnce\");\n    }\n\n    $attachExtract(...args: any[]) {\n        return this.attachExtract(...args);\n    }\n\n    attachExtract(...args: any[]) {\n        return this.__attachX(args, \"attachExtract\");\n    }\n\n    $attachPrepend(...args: any[]) {\n        return (this.attachPrepend as any)(...args);\n    }\n\n    attachPrepend(...args: any[]) {\n        return this.__attachX(args, \"attachPrepend\");\n    }\n\n    $attachOncePrepend(...args: any[]) {\n        return this.attachOncePrepend(...args);\n    }\n\n    attachOncePrepend(...args: any[]) {\n        return this.__attachX(args, \"attachOncePrepend\");\n    }\n\n    $attachOnceExtract(...args: any[]) {\n        return this.attachOnceExtract(...args);\n    }\n\n    attachOnceExtract(...args: any[]) {\n        return this.__attachX(args, \"attachOnceExtract\");\n    }\n\n    private __attachX(\n        args: any[],\n        methodName: keyof typeof EvtImpl.propsFormMethodNames\n    ): any {\n\n        const propsFromArgs = parsePropsFromArgs<T>(args, \"attach*\");\n\n        const handler = this.addHandler(\n            propsFromArgs,\n            EvtImpl.propsFormMethodNames[methodName]\n        );\n\n        return propsFromArgs.timeout === undefined ?\n            this :\n            handler.promise\n            ;\n\n    }\n\n    postAsyncOnceHandled(data: T): number | Promise<number> {\n\n        if (this.isHandled(data)) {\n            return this.post(data);\n        }\n\n        const d = new Deferred<number>();\n\n        this.evtAttach.attachOnce(\n            ({ op }) => this.isHandledByOp(op, data),\n            () => Promise.resolve().then(() => d.resolve(this.post(data)))\n        );\n\n        return d.pr;\n\n    }\n\n    private postOrPostAndWait(data: T, wait: false): number;\n    private postOrPostAndWait(data: T, wait: true): Promise<void>;\n    private postOrPostAndWait(data: T, wait: boolean): number | Promise<void> {\n\n        this.trace(data);\n\n        overwriteReadonlyProp(this, \"postCount\", this.postCount + 1);\n\n        //NOTE: Must be before postSync.\n        const postChronologyMark = this.getChronologyMark();\n\n        const [isExtracted, prAllHandlerCallbacksResolved] = this.postSync(data);\n\n        const getReturnValue = wait ?\n            () => prAllHandlerCallbacksResolved :\n            () => this.postCount;\n\n        if (isExtracted) {\n            return getReturnValue();\n        }\n\n        if (this.postAsync === undefined) {\n\n            if (this.asyncHandlerCount === 0) {\n                return getReturnValue();\n            }\n\n            this.postAsync = this.postAsyncFactory();\n\n        }\n\n        this.postAsync(data, postChronologyMark);\n\n        return getReturnValue();\n\n    }\n\n    post(data: T) {\n        return this.postOrPostAndWait(data, false);\n    }\n\n    postAndWait(data: T) {\n        return this.postOrPostAndWait(data, true);\n    }\n\n}\n\n/** \n * Can be seen as a protected method that can be \n * optionally be implemented by class extending Evt.\n * \n * Should only be accessible from within the module.\n * Basically it is for allowing StatefulEvt to execute\n * the callback on attach.\n */\nexport const onAddHandlerByEvt = new WeakMap<\n    NonPostableEvtLike<any>,\n    (\n        handler: Handler<any, any>,\n        handlerTrigger: (opResult: readonly [any]) => PromiseLike<void> | undefined\n    ) => void>();\n\n\nexport const Evt: {\n    new <T>(): Evt<T>;\n    readonly prototype: Evt<any>;\n\n    readonly create: typeof create;\n\n    readonly newCtx: typeof newCtx;\n\n    readonly merge: typeof merge;\n\n    readonly from: typeof from;\n\n    readonly getCtx: ReturnType<typeof getCtxFactory>;\n\n    readonly loosenType: typeof loosenType;\n\n    readonly factorize: typeof factorize;\n\n    readonly asPostable: typeof asPostable;\n\n    readonly asyncPipe: typeof asyncPipe;\n\n    readonly asNonPostable: typeof asNonPostable;\n\n    /** https://docs.evt.land/api/evt/setdefaultmaxhandlers */\n    setDefaultMaxHandlers(n: number): void;\n\n} = EvtImpl;\n\ntry { overwriteReadonlyProp(Evt as any, \"name\", \"Evt\"); } catch { }\n\nimportProxy.Evt = Evt;\n\n","import type { SwapEvtType, UnpackEvt, NonPostableEvtLike} from \"./types\";\n\n/**\n * https://docs.evt.land/api/evt/loosenType\n */\nexport function loosenType<E extends NonPostableEvtLike<any>, SupersetOfT>(\n    evt: E\n): UnpackEvt<E> extends SupersetOfT ?\n    SwapEvtType<typeof evt, SupersetOfT> : \"NOT A SUPERSET\" {\n    return evt as any;\n}\n\n/*\nimport { Evt } from \"./Evt\";\nconst x: Evt<boolean> = loosenType(new Evt<true>()); x;\nconst y: Evt<boolean> = loosenType(new Evt<number>()); y;\n*/\n\n\n\n","\nimport { importProxy } from \"./importProxy\";\nimport type { UnpackEvt, Evt, CtxLike, NonPostableEvtLike } from \"./types\";\n\nexport function mergeImpl<EvtUnion extends NonPostableEvtLike<any>>(\n    ctx: CtxLike<any> | undefined,\n    evts: readonly EvtUnion[]\n): Evt<UnpackEvt<EvtUnion>> {\n\n    const evtUnion = new importProxy.Evt<UnpackEvt<EvtUnion>>();\n\n    const callback = (data: UnpackEvt<typeof evtUnion>) => evtUnion.post(data)\n\n    evts.forEach(\n        evt => {\n\n            if (ctx === undefined) {\n                evt.attach(callback);\n            } else {\n                evt.attach(ctx, callback);\n            }\n\n        }\n    );\n\n    return evtUnion;\n\n}\n\n\n\n/** https://docs.evt.land/api/evt/merge */\nexport function merge<EvtUnion extends NonPostableEvtLike<any>>(\n    ctx: CtxLike<any>,\n    evts: readonly EvtUnion[]\n): Evt<UnpackEvt<EvtUnion>>;\nexport function merge<EvtUnion extends NonPostableEvtLike<any>>(\n    evts: readonly EvtUnion[]\n): Evt<UnpackEvt<EvtUnion>>;\nexport function merge<EvtUnion extends NonPostableEvtLike<any>>(\n    p1: CtxLike<any> | readonly EvtUnion[],\n    p2?: readonly EvtUnion[]\n): Evt<UnpackEvt<EvtUnion>> {\n\n    return \"length\" in p1 ?\n        mergeImpl(undefined, p1) :\n        mergeImpl(p1, p2!)\n        ;\n\n\n}","import { importProxy } from \"./importProxy\";\nimport type { Ctx } from \"./Ctx\";\n\n/** \n * https://docs.evt.land/api/evt/newctx\n * \n * return a new Ctx instance\n * */\nexport function newCtx<T = void>(): Ctx<T>{\n    return new importProxy.Ctx();\n}","\nimport type { Operator } from \"./types/Operator\"\nimport { id } from \"tsafe/id\";\nimport { compose } from \"./util/compose\";\nimport { typeGuard } from \"tsafe/typeGuard\"\nimport type { CtxLike, Handler } from \"./types\";\n\nexport function matchAll() { return true; }\n\nconst canBeOperator = (p: undefined | CtxLike<any> | Operator<any, any>): boolean => {\n    return (\n        p !== undefined &&\n        typeGuard<Operator<any, any>>(p, true) &&\n        (\n            typeof p === \"function\" ||\n            typeof p[0] === \"function\"\n        )\n    );\n};\n\nconst defaultParams: Handler.PropsFromArgs<any, any> = {\n    \"op\": matchAll,\n    \"ctx\": undefined,\n    \"timeout\": undefined,\n    \"callback\": undefined\n};\n\nexport function parsePropsFromArgs<T>(\n    inputs: readonly any[],\n    methodName: \"waitFor\" | \"attach*\" | \"pipe\"\n): Handler.PropsFromArgs<T, any> {\n\n    type Out = Handler.PropsFromArgs<T, any>;\n\n    switch (methodName) {\n        case \"pipe\": {\n\n            //[]\n            //[undefined] ( not valid but user would expect it to work )\n            //[ ctx, ...op[] ]\n            //[ ...op[] ]\n\n            const getOpWrap = (ops: [Operator<T, any>, ...Operator<any, any>[]]) =>\n                ops.length === 0 ?\n                    {}\n                    :\n                    { \"op\": ops.length === 1 ? ops[0] : compose(...ops) }\n                ;\n\n            if (canBeOperator(inputs[0])) {\n\n                //[ ...op[] ]\n\n                return id<Out>({\n                    ...defaultParams,\n                    ...getOpWrap(inputs as any)\n                });\n\n            } else {\n\n                //[]\n                //[ ctx, ...Operator.fλ[] ]\n\n                const [ctx, ...rest] = inputs;\n\n                return id<Out>({\n                    ...defaultParams,\n                    ...(ctx !== undefined ? { ctx } : {}),\n                    ...getOpWrap(rest as any)\n                });\n\n            }\n\n\n        } break;\n\n        case \"waitFor\": {\n\n            //[ op, ctx, timeout ]\n            //[ op, ctx, undefined ]\n            //[ op, ctx ]\n            //[ op, timeout ]\n            //[ op, undefined ]\n            //[ ctx, timeout ]\n            //[ ctx, undefined ]\n            //[ op ]\n            //[ ctx ]\n            //[ timeout ]\n            //[ undefined ]\n            //[ callback ]\n\n            return parsePropsFromArgs(\n                [\n                    //If the last element is undefined, remove it.\n                    ...inputs.filter(\n                        (value, index) => !(\n                            index === inputs.length - 1 &&\n                            value === undefined\n                        )\n                    ),\n                    defaultParams.callback\n                ],\n                \"attach*\"\n            );\n\n        } break;\n        case \"attach*\": {\n\n            //NOTE: when callback is undefined call has been forward from waitFor.\n\n            //[ op, ctx, timeout, callback ]\n            //[ op, ctx, timeout, undefined ]\n            //[ op, ctx, callback ]\n            //[ op, ctx, undefined ]\n            //[ op, timeout, callback ]\n            //[ op, timeout, undefined ]\n            //[ ctx, timeout, callback ]\n            //[ ctx, timeout, undefined ]\n            //[ op, callback ]\n            //[ op, undefined ]\n            //[ ctx, callback ]\n            //[ ctx, undefined ]\n            //[ timeout, callback ]\n            //[ timeout, undefined ]\n            //[ callback ]\n            //[ undefined ]\n\n            const n = inputs.length as 4 | 3 | 2 | 1 | 0;\n\n            switch (n) {\n                case 4: {\n\n                    //[ op, ctx, timeout, callback ]\n                    const [p1, p2, p3, p4] = inputs;\n\n                    return id<Out>({\n                        ...defaultParams,\n                        \"op\": p1,\n                        \"ctx\": p2,\n                        \"timeout\": p3,\n                        \"callback\": p4\n                    });\n\n                }\n                case 3: {\n\n                    //[ op, ctx, callback ]\n                    //[ op, timeout, callback ]\n                    //[ ctx, timeout, callback ]\n                    const [p1, p2, p3] = inputs;\n                    if (typeof p2 === \"number\") {\n                        //[ op, timeout, callback ]\n                        //[ ctx, timeout, callback ]\n\n                        const timeout: Out[\"timeout\"] = p2;\n                        const callback: Out[\"callback\"] = p3;\n\n                        if (canBeOperator(p1)) {\n                            //[ op, timeout, callback ]\n                            return id<Out>({\n                                ...defaultParams,\n                                timeout,\n                                callback,\n                                \"op\": p1\n                            });\n\n                        } else {\n                            //[ ctx, timeout, callback ]\n\n                            return id<Out>({\n                                ...defaultParams,\n                                timeout,\n                                callback,\n                                \"ctx\": p1\n                            });\n\n                        }\n                    } else {\n                        //[ op, ctx, callback ]\n                        return id<Out>({\n                            ...defaultParams,\n                            \"op\": p1,\n                            \"ctx\": p2,\n                            \"callback\": p3\n                        });\n\n                    }\n\n                }\n                case 2: {\n\n                    //[ op, callback ]\n                    //[ ctx, callback ]\n                    //[ timeout, callback ]\n                    const [p1, p2] = inputs;\n                    if (typeof p1 === \"number\") {\n                        //[ timeout, callback ]\n                        return id<Out>({\n                            ...defaultParams,\n                            \"timeout\": p1,\n                            \"callback\": p2\n                        });\n                    } else {\n                        //[ op, callback ]\n                        //[ ctx, callback ]\n                        const callback: Out[\"callback\"] = p2;\n                        if (canBeOperator(p1)) {\n\n                            return id<Out>({\n                                ...defaultParams,\n                                callback,\n                                \"op\": p1\n                            });\n\n                        } else {\n\n                            return id<Out>({\n                                ...defaultParams,\n                                callback,\n                                \"ctx\": p1\n                            });\n\n                        }\n                    }\n\n                }\n                case 1: {\n\n                    //[ callback ]\n                    const [p] = inputs;\n\n                    return id<Out>({\n                        ...defaultParams,\n                        \"callback\": p\n                    });\n\n                }\n                case 0: {\n                    return id<Out>({ ...defaultParams });\n                }\n\n            }\n\n\n        } break;\n\n    }\n\n}\n\n","import { overwriteReadonlyProp } from \"tsafe/lab/overwriteReadonlyProp\";\nimport { importProxy } from \"./importProxy\";\nimport type { Evt } from \"./types\";\n\nexport class LazyEvt<T> {\n\n    private initialPostCount = 0;\n\n    get evt(): Evt<T> {\n\n        if (this.__evt === undefined) {\n            this.__evt = new importProxy.Evt();\n            overwriteReadonlyProp(this.__evt, \"postCount\", this.initialPostCount);\n        }\n\n        return this.__evt;\n\n    }\n\n    declare private __evt: Evt<T>;\n\n    private __post(data: T, doWait: false): number;\n    private __post(data: T, doWait: true): Promise<void>;\n    private __post(data: T, doWait: boolean): number | Promise<void> {\n\n        if (this.__evt === undefined) {\n\n            return ++this.initialPostCount;\n\n        }\n\n        return this.__evt[doWait ? \"postAndWait\" : \"post\"](data);\n\n    }\n\n    post(data: T) {\n        return this.__post(data, false);\n    }\n\n    postAndWait(data: T) {\n        return this.__post(data, true);\n    }\n\n}\n","\nimport type { Ctx } from \"./Ctx\";\nimport type { Evt } from \"./Evt\";\nimport type { StatefulEvt } from \"./StatefulEvt\";\n\n/** Manually handling circular import so React Native does not gives warning. */\nexport const importProxy: {\n    Ctx: typeof Ctx;\n    Evt: typeof Evt;\n    StatefulEvt: typeof StatefulEvt;\n} = {} as any;\n\n\n\n","\nimport { typeGuard } from \"tsafe/typeGuard\";\n\nexport type EventTargetLike<T> =\n    EventTargetLike.HasEventTargetAddRemove<T> |\n    EventTargetLike.NodeStyleEventEmitter |\n    EventTargetLike.JQueryStyleEventEmitter |\n    EventTargetLike.RxJSSubject<T>\n    ;\n\nexport namespace EventTargetLike {\n\n    export type HTMLElement = HasEventTargetAddRemove<any> & {\n        innerText: string;\n    };\n\n    export type Window = HasEventTargetAddRemove<any> & {\n        document: EventTargetLike.Document;\n    };\n\n    export type Document = HasEventTargetAddRemove<any> & {\n        URL: string;\n    };\n\n    export type RxJSSubject<T> = {\n        subscribe: (next: (data: T) => void) => RxJSSubject.Subscription;\n    };\n\n    export namespace RxJSSubject {\n\n        export type Subscription = {\n            unsubscribe(): void;\n        };\n\n        export function match<T>(eventTarget: EventTargetLike<T>): eventTarget is RxJSSubject<T> {\n            return (\n                typeGuard<RxJSSubject<T>>(eventTarget, true) &&\n                eventTarget instanceof Object &&\n                typeof eventTarget.subscribe === \"function\"\n            );\n        }\n\n\n    }\n\n\n    export type NodeStyleEventEmitter =\n        NodeStyleEventEmitter.Compat |\n        NodeStyleEventEmitter.Regular\n        ;\n\n    export namespace NodeStyleEventEmitter {\n\n        export interface Regular {\n            addListener: (eventName: string | symbol, handler: NodeEventHandler) => this;\n            removeListener: (eventName: string | symbol, handler: NodeEventHandler) => this;\n        };\n\n        export interface Compat {\n            addListener: (eventName: string, handler: NodeEventHandler) => void | {};\n            removeListener: (eventName: string, handler: NodeEventHandler) => void | {};\n        }\n\n        export declare type NodeEventHandler = (...args: any[]) => void;\n\n        export function match<T>(eventTarget: EventTargetLike<T>): eventTarget is NodeStyleEventEmitter {\n            return (\n                typeGuard<NodeStyleEventEmitter>(eventTarget, true) &&\n                eventTarget instanceof Object &&\n                typeof eventTarget.addListener === \"function\" &&\n                typeof eventTarget.removeListener === \"function\"\n            );\n        }\n\n    }\n\n    export interface JQueryStyleEventEmitter {\n        on: (eventName: string, handler: Function) => void;\n        off: (eventName: string, handler: Function) => void;\n    }\n\n    export namespace JQueryStyleEventEmitter {\n\n        export function match<T>(eventTarget: EventTargetLike<T>): eventTarget is JQueryStyleEventEmitter {\n            return (\n                typeGuard<JQueryStyleEventEmitter>(eventTarget, true) &&\n                eventTarget instanceof Object &&\n                typeof eventTarget.on === \"function\" &&\n                typeof eventTarget.off === \"function\"\n            );\n        }\n\n    }\n\n    export interface HasEventTargetAddRemove<E> {\n        addEventListener(type: string, listener: ((evt: E) => void) | null, options?: boolean | HasEventTargetAddRemove.Options): void;\n        removeEventListener(type: string, listener?: ((evt: E) => void) | null, options?: HasEventTargetAddRemove.Options | boolean): void;\n    }\n\n    export namespace HasEventTargetAddRemove {\n\n        export interface Options {\n            capture?: boolean;\n            passive?: boolean;\n            once?: boolean;\n        }\n\n        export function match<T>(eventTarget: EventTargetLike<T>): eventTarget is HasEventTargetAddRemove<T> {\n            return (\n                typeGuard<HasEventTargetAddRemove<T>>(eventTarget, true) &&\n                eventTarget instanceof Object &&\n                typeof eventTarget.addEventListener === \"function\" &&\n                typeof eventTarget.removeEventListener === \"function\"\n            );\n        }\n\n    }\n\n\n    /* Return true if o can be a EventTargetLike */\n    export function canBe(o: any): boolean {\n\n        try{\n\n            return (\n                HasEventTargetAddRemove.match(o) ||\n                NodeStyleEventEmitter.match(o) ||\n                JQueryStyleEventEmitter.match(o) ||\n                RxJSSubject.match(o)\n            );\n\n        }catch{\n\n            return false;\n\n        }\n\n    }\n\n\n}\n","\n\nexport class TimeoutEvtError extends Error {\n    constructor(public readonly timeout: number) {\n        super(`Evt timeout after ${timeout}ms`);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n\nexport class DetachedEvtError extends Error {\n    constructor() {\n        super(`Evt handler detached`);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n\n\n\n","\nimport { typeGuard } from \"tsafe/typeGuard\";\nimport type { NonPostableEvtLike } from \"./NonPostableEvtLike\";\nimport type { Handler } from \"../Handler\";\n\n/** \n * Minimal interface that an object must implement to be a valid context argument \n * ( for interop between mismatching EVT versions )\n * */\nexport interface CtxLike<Result = any> {\n    done(result: Result): void;\n    abort(error: Error): void;\n    zz__addHandler<T>(handler: Handler<T, any, CtxLike<Result>>, evt: NonPostableEvtLike<T>): void;\n    zz__removeHandler<T>(handler: Handler<T, any, CtxLike<Result>>): void;\n}\n\nexport namespace CtxLike {\n\n    export function match<T=any>(o: any): o is CtxLike<T> {\n        return (\n            typeGuard<CtxLike>(o, true) &&\n            o instanceof Object &&\n            typeof o.done === \"function\" &&\n            typeof o.abort === \"function\" &&\n            typeof o.zz__addHandler === \"function\" &&\n            typeof o.zz__removeHandler === \"function\"\n        );\n    }\n\n}\n","import { convertOperatorToStatelessFλ } from \"./convertOperatorToStatelessFLambda\";\nimport { id } from \"tsafe/id\";\nimport type { Operator } from \"../types/Operator\";\n\nfunction f_o_g<A, B, C>(\n    op1: Operator<A, B>,\n    op2: Operator<B, C>\n): Operator.fλ.Stateless<A, C> {\n\n    const opAtoB = convertOperatorToStatelessFλ(op1);\n\n    const opBtoC = convertOperatorToStatelessFλ(op2);\n\n    return id<Operator.fλ.Stateless<A, C>>(\n        (dataA, registerSideEffect) => {\n\n            const resultB = opAtoB(dataA, registerSideEffect);\n\n            if( !resultB ){\n                return null;\n            }\n\n            const [dataB] = resultB;\n\n            const resultC = opBtoC(dataB, registerSideEffect);\n\n            if( !resultC ){\n                return resultC;\n            }\n\n            return [resultC[0]];\n\n        }\n    );\n}\n\n\nexport function compose<A, B, C>(\n    op1: Operator.fλ<A, B>,\n    op2: Operator.fλ<B, C>\n): Operator.fλ.Stateless<A, C>;\nexport function compose<A, B, C extends B>(\n    op1: Operator.fλ<A, B>,\n    op2: (data: B) => data is C,\n): Operator.fλ.Stateless<A, C>;\nexport function compose<A, B>(\n    op1: Operator.fλ<A, B>,\n    op2: (data: B) => boolean,\n): Operator.fλ.Stateless<A, B>;\nexport function compose<A, B extends A, C>(\n    op1: (data: A) => data is B,\n    op2: Operator.fλ<B, C>\n): Operator.fλ.Stateless<A, B>;\nexport function compose<A, B>(\n    op1: (data: A) => boolean,\n    op2: Operator.fλ<A, B>\n): Operator.fλ.Stateless<A, B>;\nexport function compose<A, B extends A, C extends B>(\n    op1: (data: A) => data is B,\n    op2: (data: B) => data is C,\n): Operator.fλ.Stateless<A, C>;\nexport function compose<A, B extends A>(\n    op1: (data: A) => data is B,\n    op2: (data: B) => boolean,\n): Operator.fλ.Stateless<A, B>;\nexport function compose<A, B extends A>(\n    op1: (data: A) => boolean,\n    op2: (data: A) => data is B\n): Operator.fλ.Stateless<A, B>;\nexport function compose<A>(\n    op1: (data: A) => boolean,\n    op2: (data: A) => boolean,\n): Operator.fλ.Stateless<A, A>;\n\n\nexport function compose<A, B, C, D>(\n    op1: Operator.fλ<A, B>,\n    op2: Operator.fλ<B, C>,\n    op3: Operator.fλ<C, D>\n): Operator.fλ.Stateless<A, D>;\n\nexport function compose<A, B, C, D, E>(\n    op1: Operator.fλ<A, B>,\n    op2: Operator.fλ<B, C>,\n    op3: Operator.fλ<C, D>,\n    op4: Operator.fλ<D, E>\n): Operator.fλ.Stateless<A, E>;\n\nexport function compose<A, B, C, D, E>(\n    op1: Operator.fλ<A, B>,\n    op2: Operator.fλ<B, C>,\n    op3: Operator.fλ<C, D>,\n    op4: Operator.fλ<D, E>\n): Operator.fλ.Stateless<A, E>;\n\nexport function compose<A, B, C, D, E, F>(\n    op1: Operator.fλ<A, B>,\n    op2: Operator.fλ<B, C>,\n    op3: Operator.fλ<C, D>,\n    op4: Operator.fλ<D, E>,\n    op5: Operator.fλ<E, F>\n): Operator.fλ.Stateless<A, F>;\n\n\nexport function compose<A, B, C>(\n    op1: Operator<A, B>,\n    op2: Operator<B, C>\n): Operator.fλ.Stateless<A, C>;\n\nexport function compose<A, B, C, D>(\n    op1: Operator<A, B>,\n    op2: Operator<B, C>,\n    op3: Operator<C, D>\n): Operator.fλ.Stateless<A, D>;\n\nexport function compose<A, B, C, D, E>(\n    op1: Operator<A, B>,\n    op2: Operator<B, C>,\n    op3: Operator<C, D>,\n    op4: Operator<D, E>,\n): Operator.fλ.Stateless<A, E>;\n\nexport function compose<A, B, C, D, E, F>(\n    op1: Operator<A, B>,\n    op2: Operator<B, C>,\n    op3: Operator<C, D>,\n    op4: Operator<D, E>,\n    op5: Operator<E, F>\n): Operator.fλ.Stateless<A, F>;\n\n\nexport function compose<T>(\n    ...ops: [\n        Operator<T, any>,\n        ...Operator<any, any>[]\n    ]\n): Operator.fλ.Stateless<T, any>;\n\nexport function compose<T>(\n    ...ops: [\n        Operator<T, any>,\n        ...Operator<any, any>[]\n    ]\n): Operator.fλ.Stateless<T, any>  {\n\n    if (ops.length === 1) {\n\n        const [op] = ops;\n\n        return convertOperatorToStatelessFλ(op);\n\n    }\n\n    const [op1, op2, ...rest] = ops;\n\n    const op1_o_op2 = f_o_g(op1, op2);\n\n    if (rest.length === 0) {\n        return op1_o_op2;\n    }\n\n    return compose(op1_o_op2, ...rest);\n\n\n}\n","\nimport type { Operator } from \"../types/Operator\";\n\nfunction encapsulateOpState<T, U>(\n    statefulFλOp: Operator.fλ.Stateful<T, U>\n): Operator.fλ.Stateless<T, U> {\n\n    let state: U = statefulFλOp[1];\n\n    return (data, registerSideEffect) => {\n\n        const opResult = statefulFλOp[0](data, state, registerSideEffect);\n\n        if (opResult !== null) {\n            registerSideEffect(() => state = opResult[0])\n        }\n\n        return opResult;\n\n    };\n\n}\n\nfunction statelessOpToStatelessFλ<T, U>(op: Operator.Stateless<T, U>): Operator.fλ.Stateless<T, U> {\n    return (data, registerSideEffect) => {\n\n        /* NOTE: Here, if the user is using TypeScript we should have readonly [U] or boolean\n         * but users using vanilla JS can very well provide operators like: text => text.match(/^error/) \n         * and expect things to work event if String.prototype.match returns a RegExpMatch array instead \n         * of boolean. \n         * Long story short we do our best to guess what the user meant with he's operator, if it was\n         * intended to be a filter or a fλ.\n         */\n        const opResult: any = (op as Operator.fλ.Stateless<T, U>)(data, registerSideEffect);\n\n        return (\n            opResult instanceof Object &&\n            !(\"input\" in opResult) && //exclude String.prototype.match\n            opResult.length === 1\n        ) ?\n            opResult\n            :\n            !!opResult ? [data] : null;\n\n    }\n};\n\nexport function convertOperatorToStatelessFλ<T, U>(\n    op: Operator<T, U>\n): Operator.fλ.Stateless<T, U> {\n    return typeof op !== \"function\" ?\n        encapsulateOpState(op) :\n        statelessOpToStatelessFλ(op);\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { overwriteReadonlyProp } from \"./lab/overwriteReadonlyProp\";\nimport { assertIsRefWrapper } from \"./zz_internal/assertIsRefWrapper\";\n\n/** @see <https://docs.tsafe.dev/assert#error-thrown> */\nexport class AssertionError extends Error {\n    constructor(msg: string | undefined) {\n        super(`Wrong assertion encountered` + (!msg ? \"\" : `: \"${msg}\"`));\n\n        Object.setPrototypeOf(this, new.target.prototype);\n\n        if (!this.stack) {\n            return;\n        }\n\n        try {\n            overwriteReadonlyProp(\n                this,\n                \"stack\",\n                this.stack\n                    .split(\"\\n\")\n                    .filter((...[, i]) => i !== 1 && i !== 2)\n                    .join(\"\\n\"),\n            );\n            // eslint-disable-next-line no-empty\n        } catch {}\n    }\n}\n\n/** https://docs.tsafe.dev/assert */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function assert<_T extends true>(condition?: any, msg?: string): asserts condition {\n    if (arguments.length === 0) {\n        condition = true;\n    }\n    if (assertIsRefWrapper.ref !== undefined) {\n        assertIsRefWrapper.ref = undefined;\n        return;\n    }\n\n    if (!condition) {\n        throw new AssertionError(msg);\n    }\n}\n","/** https://docs.tsafe.dev/id  */\nexport const id = <T>(x: T) => x;\n\n/**\n * Ensure that a that a specific type that we are declaring extends a more generic type\n *\n * Use case example 1:\n *\n * type MyObject = {\n *     p1: string;\n *     p2: string;\n *     a: string;\n *     b: string;\n * };\n *\n * We want to define a type that consist in an union of\n * all the property name that are letters:\n *\n * type AlphabeticalKeys = Id<keyof MyObject, \"a\" | \"b\">;\n *\n * Here AlphabeticalKeys is \"a\" | \"b\" but it's better than\n * simply writing it explicitly as we get autocompletion\n * and we can't include a property name that does not exist on MyObject.\n *\n * Use case example 2:\n *\n * We want to declare object type that only take string or number\n * as key value:\n *\n * export type MyObject = Id<Record<string, string | number>, {\n *     p1: string;\n *     p2: number;\n * }>;\n *\n * If later on someone adds \"p3\": string[] he will get a type error.\n * */\nexport type Id<Generic, Specific extends Generic> = Specific;\n","/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { assertIsRefWrapper } from \"./zz_internal/assertIsRefWrapper\";\n\nconst errorMessage = [\n    `Wrong usage of the ${is.name} function refer to`,\n    `https://docs.tsafe.dev/${is.name.toLowerCase()}`,\n].join(\" \");\n\nexport function is<T>(_value: any): _value is T {\n    const ref = {};\n\n    if (assertIsRefWrapper.ref !== undefined) {\n        assertIsRefWrapper.ref = undefined;\n        throw new Error(errorMessage);\n    }\n\n    assertIsRefWrapper.ref = ref;\n\n    Promise.resolve().then(() => {\n        if (assertIsRefWrapper.ref === ref) {\n            throw new Error(errorMessage);\n        }\n    });\n\n    return null as any;\n}\n","// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isPromiseLike<T = void>(o: any): o is PromiseLike<T> {\n    return typeof o?.then === \"function\";\n}\n","/* eslint-disable no-empty */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { assert } from \"../assert\";\nimport { is } from \"../is\";\n\n/**\n * Assign a value to a property even if the object is freezed or if the property is not writable\n * Throw if the assignation fail ( for example if the property is non configurable write: false )\n * */\nexport const overwriteReadonlyProp = <T extends { [key: string]: any }, K extends keyof T>(\n    obj: T,\n    propertyName: K,\n    value: T[K],\n): T[K] => {\n    try {\n        obj[propertyName] = value;\n    } catch {}\n\n    if (obj[propertyName] === value) {\n        return value;\n    }\n\n    let errorDefineProperty: Error | undefined = undefined;\n\n    const propertyDescriptor: PropertyDescriptor = Object.getOwnPropertyDescriptor(\n        obj,\n        propertyName,\n    ) || {\n        \"enumerable\": true,\n        \"configurable\": true,\n    };\n\n    if (!!propertyDescriptor.get) {\n        throw new Error(`Probably a wrong ides to overwrite ${String(propertyName)} getter`);\n    }\n\n    try {\n        Object.defineProperty(obj, propertyName, {\n            ...propertyDescriptor,\n            value,\n        });\n    } catch (error) {\n        assert(is<Error>(error));\n        errorDefineProperty = error;\n    }\n\n    if (obj[propertyName] !== value) {\n        throw errorDefineProperty || new Error(\"Can't assign\");\n    }\n\n    return value;\n};\n","/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/** https://docs.tsafe.dev/typeguard */\nexport function typeGuard<T>(_value: any, isMatched: boolean): _value is T {\n    return isMatched;\n}\n","import { id } from \"../id\";\n\nexport const assertIsRefWrapper = {\n    \"ref\": id<undefined | Record<string, never>>(undefined),\n};\n","\nimport { overwriteReadonlyProp } from \"tsafe/lab/overwriteReadonlyProp\";\n\nexport class Deferred<T> {\n\n    public readonly pr: Promise<T>;\n\n    /** NOTE: Does not need to be called bound to instance*/\n    public readonly resolve: (value: T)=> void;\n    public readonly reject: (error: any)=> void;\n\n    constructor() {\n\n        let resolve!: (value: T)=> void;\n        let reject!: (error: any)=> void;\n\n        this.pr = new Promise<T>(\n            (resolve_, reject_) => {\n\n                resolve = value => {\n\n                    overwriteReadonlyProp(this, \"isPending\", false);\n                    resolve_(value);\n\n                };\n\n                reject = error => {\n\n\n                    overwriteReadonlyProp(this, \"isPending\", false);\n                    reject_(error);\n\n                };\n\n            }\n        );\n\n        this.resolve = resolve;\n        this.reject = reject;\n\n    }\n\n\n    public readonly isPending: boolean = true;\n\n\n}\n\nexport namespace Deferred {\n\n    export type Unpack<T extends Deferred<any>> = T extends Deferred<infer U> ? U : never;\n\n}\n\nexport class VoidDeferred extends Deferred<undefined>{\n\n    declare public readonly resolve: () => void;\n\n}\n\n\n\n\n\n\n\n","\n//NOTE: Deno can't use NodeJS type def ( obviously )\nexport type Timer= { _timerBrand: any; };\nexport const safeSetTimeout = (callback: () => void, ms: number): Timer => setTimeout(callback, ms) as any;\nexport const safeClearTimeout = (timer: Timer): void => clearTimeout(timer as any);","\nimport { Polyfill as WeakMap } from \"minimal-polyfills/WeakMap\";\n\nclass ExecQueue {\n\n    public readonly queuedCalls: Function[]=[];\n\n    public isRunning: boolean= false;\n\n    //TODO: move where it is used.\n    public cancelAllQueuedCalls(): number {\n\n        let n: number;\n\n        this.queuedCalls.splice(0, n=this.queuedCalls.length);\n\n        return n;\n\n    }\n\n    public prComplete: Promise<void>= Promise.resolve();\n\n\n}\n\n\nconst globalContext: Object = {};\n\nconst clusters = new WeakMap<Object, WeakMap<GroupRef,ExecQueue>>();\n\n//console.log(\"Map version\");\n//export const clusters = new Map<Object, Map<GroupRef,ExecQueue>>();\n\n\nfunction getOrCreateExecQueue(\n    context: Object, \n    groupRef: GroupRef\n): ExecQueue {\n\n    let execQueueByGroup = clusters.get(context);\n\n    if (!execQueueByGroup) {\n        execQueueByGroup = new WeakMap();\n        clusters.set(context, execQueueByGroup);\n    }\n\n    let execQueue= execQueueByGroup.get(groupRef);\n\n    if (!execQueue){\n        execQueue= new ExecQueue();\n        execQueueByGroup.set(groupRef, execQueue);\n    }\n\n    return execQueue;\n\n}\n\nexport type GroupRef = never[];\n\nexport function createGroupRef(): GroupRef {\n    return new Array<never>(0);\n}\n\n/**\n * Built a run-exclusive function from a function that return a promise.\n */\nexport function build<T extends (...input: any[]) => Promise<any>>(fun: T): T;\n/**\n * Built a run-exclusive function from a function that return a promise.\n * \n * The group ref parameter is used when in need that two or more different functions do nor run simultaneously.\n * Group refs are created by calling createGroupRef().\n */\nexport function build<T extends (...input: any[]) => Promise<any>>(groupRef: GroupRef, fun: T): T;\nexport function build(...inputs: any[]): any {\n\n    switch (inputs.length) {\n        case 1: return buildFnPromise(true, createGroupRef(), inputs[0]);\n        case 2: return buildFnPromise(true, inputs[0], inputs[1]);\n    }\n\n}\n\n\n/** Same as build but to restrict the exclusion to a class instance object. */\nexport function buildMethod<T extends (...input: any[]) => Promise<any>>(fun: T): T;\nexport function buildMethod<T extends (...input: any[]) => Promise<any>>(groupRef: GroupRef, fun: T): T;\nexport function buildMethod(...inputs: any[]): any {\n\n    switch (inputs.length) {\n        case 1: return buildFnPromise(false, createGroupRef(), inputs[0]);\n        case 2: return buildFnPromise(false, inputs[0], inputs[1]);\n    }\n\n}\n\n/** \n * \n * Get the number of queued call of a run-exclusive function. \n * Note that if you call a runExclusive function and call this \n * directly after it will return 0 as there is one function call\n * execution ongoing but 0 queued.\n * \n * The classInstanceObject parameter is to provide only for the run-exclusive\n * function created with 'buildMethod[Cb].\n *  \n * */\nexport function getQueuedCallCount(\n    runExclusiveFunction: Function,\n    classInstanceObject?: Object\n): number {\n\n    const execQueue= getExecQueueByFunctionAndContext(runExclusiveFunction, classInstanceObject);\n\n    return execQueue?execQueue.queuedCalls.length:0;\n\n}\n\n/**\n * \n * Cancel all queued calls of a run-exclusive function.\n * Note that the current running call will not be cancelled.\n * \n * The classInstanceObject parameter is to provide only for the run-exclusive\n * function created with 'buildMethod[Cb].\n * \n */\nexport function cancelAllQueuedCalls(\n    runExclusiveFunction: Function,\n    classInstanceObject?: Object\n): number {\n\n    const execQueue= getExecQueueByFunctionAndContext(runExclusiveFunction, classInstanceObject);\n\n    return execQueue?execQueue.cancelAllQueuedCalls():0;\n\n}\n\n/**\n * Tell if a run-exclusive function has an instance of it's call currently being\n * performed.\n * \n * The classInstanceObject parameter is to provide only for the run-exclusive\n * function created with 'buildMethod[Cb].\n */\nexport function isRunning(\n    runExclusiveFunction: Function,\n    classInstanceObject?: Object\n): boolean {\n\n    const execQueue= getExecQueueByFunctionAndContext(runExclusiveFunction, classInstanceObject);\n\n    return execQueue?execQueue.isRunning:false;\n\n}\n\n/**\n * Return a promise that resolve when all the current queued call of a runExclusive functions\n * have completed.\n * \n * The classInstanceObject parameter is to provide only for the run-exclusive\n * function created with 'buildMethod[Cb].\n */\nexport function getPrComplete(\n    runExclusiveFunction: Function,\n    classInstanceObject?: Object\n): Promise<void>{\n\n    const execQueue= getExecQueueByFunctionAndContext(runExclusiveFunction, classInstanceObject);\n\n    return execQueue?execQueue.prComplete:Promise.resolve();\n\n}\n\nconst groupByRunExclusiveFunction= new WeakMap<Function, GroupRef>();\n\nfunction getExecQueueByFunctionAndContext(\n    runExclusiveFunction: Function,\n    context = globalContext\n): ExecQueue | undefined {\n\n    const groupRef= groupByRunExclusiveFunction.get(runExclusiveFunction);\n\n    if( !groupRef ){\n        throw Error(\"Not a run exclusiveFunction\");\n    }\n\n    const execQueueByGroup= clusters.get(context);\n\n    if( !execQueueByGroup ){\n        return undefined;\n    }\n\n    return execQueueByGroup.get(groupRef)!;\n\n}\n\n\nfunction buildFnPromise<T extends (...inputs: any[]) => Promise<any>>(\n    isGlobal: boolean,\n    groupRef: GroupRef,\n    fun: T\n): T {\n\n    let execQueue: ExecQueue;\n\n    const runExclusiveFunction = (function (this: any, ...inputs) {\n\n        if (!isGlobal) {\n\n            if (!(this instanceof Object)) {\n                throw new Error(\"Run exclusive, <this> should be an object\");\n            }\n\n            execQueue = getOrCreateExecQueue(this, groupRef);\n\n        }\n\n        return new Promise<any>((resolve, reject) => {\n\n            let onPrCompleteResolve: () => void;\n\n            execQueue.prComplete = new Promise(resolve =>\n                onPrCompleteResolve = () => resolve()\n            );\n\n            const onComplete = (result: { data: any } | { reason: any }) => {\n\n                onPrCompleteResolve();\n\n                execQueue.isRunning = false;\n\n                if (execQueue.queuedCalls.length) {\n                    execQueue.queuedCalls.shift()!();\n                }\n\n                if (\"data\" in result) {\n                    resolve(result.data);\n                } else {\n                    reject(result.reason);\n                }\n\n            };\n\n            (function callee(this: any,...inputs: any[]) {\n\n                if (execQueue.isRunning) {\n                    execQueue.queuedCalls.push(() => callee.apply(this, inputs));\n                    return;\n                }\n\n                execQueue.isRunning = true;\n\n                try {\n\n                    fun.apply(this, inputs)\n                        .then(data => onComplete({ data }))\n                        .catch(reason => onComplete({ reason }))\n                        ;\n\n                } catch (error) {\n\n                    onComplete({ \"reason\": error });\n\n                }\n\n            }).apply(this, inputs);\n\n        });\n\n    }) as T;\n\n    if (isGlobal) {\n\n        execQueue = getOrCreateExecQueue(globalContext, groupRef);\n\n    }\n\n    groupByRunExclusiveFunction.set(runExclusiveFunction, groupRef);\n\n    return runExclusiveFunction;\n\n}\n\n/** \n * (Read all before using)\n * \n * The pending of 'build' for creating run exclusive functions that complete\n * via calling a callback function. (Instead of returning a promise).\n * \n * The only valid reason to use this instead of ``build()`` is to be able to\n * retrieve the result and/or release the lock synchronously when it's possible.\n * \n * If you want the callback to be optional it is possible to \n * define the function as such:   \n * ``const myRunExclusiveFunction = buildCb((callback?)=> { ... });``  \n * Anyway you must call it every time and assume it has been defined:\n * ``callback!(...)``.   \n * \n * To see if the user has actually provided a callback you can access the hidden property\n * ``callback.hasCallback``.\n * \n * WARNING: You must also make sure, if you use an optional callback \n * that the argument before it cannot be a function.   \n * Be aware that the compiler won't warn you against it.  \n * Example: ``(getLetter:()=> string, callback?:(res:string)=> void)=>{..}``  \n * is NOT a valid function to pass to ``buildCb()`` \n * \n * WARNING: the source function should NEVER throw exception!\n */\nexport function buildCb<T extends (...input: any[]) => void>(fun: T): T;\nexport function buildCb<T extends (...input: any[]) => void>(groupRef: GroupRef, fun: T): T;\nexport function buildCb(...inputs: any[]): any {\n\n    switch (inputs.length) {\n        case 1: return buildFnCallback(true, createGroupRef(), inputs[0]);\n        case 2: return buildFnCallback(true, inputs[0], inputs[1]);\n    }\n\n}\n\n/** \n * (Read all before using)\n * \n * Pending of 'buildMethod' for function that return with callback instead of promise.\n * \n * The pending of 'build' for creating run exclusive functions that complete\n * via calling a callback function. (Instead of returning a promise).\n * \n * The only valid reason to use this instead of ``build()`` is to be able to\n * retrieve the result and/or release the lock synchronously when it's possible.\n * \n * If you want the callback to be optional it is possible to \n * define the function as such:   \n * ``const myRunExclusiveFunction = buildCb((callback?)=> { ... });``  \n * Anyway you must call it every time and assume it has been defined:\n * ``callback!(...)``.   \n * \n * To see if the user has actually provided a callback you can access the hidden property\n * ``callback.hasCallback``.\n * \n * WARNING: You must also make sure, if you use an optional callback \n * that the argument before it cannot be a function.   \n * Be aware that the compiler won't warn you against it.  \n * Example: ``(getLetter:()=> string, callback?:(res:string)=> void)=>{..}``  \n * is NOT a valid function to pass to ``buildMethodCb()``\n * \n * WARNING: the source function should NEVER throw exception!\n * \n */\nexport function buildMethodCb<T extends (...input: any[]) => void>(fun: T): T;\nexport function buildMethodCb<T extends (...input: any[]) => void>(groupRef: GroupRef, fun: T): T;\nexport function buildMethodCb(...inputs: any[]): any {\n\n    switch (inputs.length) {\n        case 1: return buildFnCallback(false, createGroupRef(), inputs[0]);\n        case 2: return buildFnCallback(false, inputs[0], inputs[1]);\n    }\n\n}\n\nfunction buildFnCallback<T extends (...inputs: any[]) => Promise<any>>(\n    isGlobal: boolean,\n    groupRef: GroupRef,\n    fun: T\n): T {\n\n    let execQueue: ExecQueue;\n\n    const runExclusiveFunction = (function (this: any,...inputs) {\n\n\n        if (!isGlobal) {\n\n            if (!(this instanceof Object)) {\n                throw new Error(\"Run exclusive, <this> should be an object\");\n            }\n\n            execQueue = getOrCreateExecQueue(this, groupRef);\n\n        }\n\n        let callback: Function | undefined = undefined;\n\n        if (inputs.length && typeof inputs[inputs.length - 1] === \"function\") {\n            callback = inputs.pop();\n        }\n\n        let onPrCompleteResolve: () => void;\n\n        execQueue.prComplete = new Promise(resolve =>\n            onPrCompleteResolve = () => resolve()\n        );\n\n        const onComplete = (...inputs: any[]) => {\n            \n            onPrCompleteResolve();\n\n            execQueue!.isRunning = false;\n\n            if (execQueue.queuedCalls.length) {\n                execQueue.queuedCalls.shift()!();\n            }\n\n            if (callback) {\n                callback.apply(this, inputs);\n            }\n\n        };\n\n        (onComplete as any).hasCallback = !!callback;\n\n        (function callee(this: any, ...inputs: any[]) {\n\n            if (execQueue.isRunning) {\n                execQueue.queuedCalls.push(() => callee.apply(this, inputs));\n                return;\n            }\n\n            execQueue.isRunning = true;\n\n            try {\n\n                fun.apply(this, [...inputs, onComplete]);\n\n            } catch (error) {\n\n                error.message += \" ( This exception should not have been thrown, miss use of run-exclusive buildCb )\";\n\n                throw error;\n\n            }\n\n        }).apply(this, inputs);\n\n    }) as T;\n\n    if (isGlobal) {\n\n        execQueue = getOrCreateExecQueue(globalContext, groupRef);\n\n    }\n\n    groupByRunExclusiveFunction.set(runExclusiveFunction, groupRef);\n\n    return runExclusiveFunction;\n\n}\n\n","\r\n\r\nexport interface LightMap<K,V> {\r\n    [Symbol.toStringTag]: string;\r\n    has(key: K): boolean;\r\n    get(key: K): V | undefined;\r\n    set(key: K, value: V): this;\r\n    delete(key: K): boolean;\r\n    keys(): Iterable<K>;\r\n}\r\n\r\nexport class LightMapImpl<K,V> implements LightMap<K,V> {\r\n\r\n    [Symbol.toStringTag]: string;\r\n\r\n    private readonly record: [K, V][]= [];\r\n\r\n    constructor(){ }\r\n\r\n    public has(key: K): boolean {\r\n        return this.record\r\n            .map(([_key]) => _key)\r\n            .indexOf(key) >= 0;\r\n    }\r\n\r\n    public get(key: K): V | undefined {\r\n\r\n        const [ entry ]= this.record\r\n            .filter(([_key]) => _key === key)\r\n            ;\r\n\r\n        if( entry === undefined ){\r\n            return undefined;\r\n        }\r\n\r\n        return entry[1];\r\n\r\n    }\r\n\r\n    public set(key: K, value: V) {\r\n\r\n        const [ entry ]= this.record\r\n            .filter(([_key]) => _key === key)\r\n            ;\r\n\r\n        if( entry === undefined ){\r\n\r\n            this.record.push([key, value]);\r\n\r\n        }else{\r\n\r\n            entry[1]= value;\r\n\r\n        }\r\n\r\n        return this;\r\n\r\n    }\r\n\r\n    public delete(key: K): boolean{\r\n\r\n        const index= this.record.map(([ key])=> key).indexOf(key);\r\n\r\n        if( index < 0 ){\r\n            return false;\r\n        }\r\n\r\n        this.record.splice(index, 1);\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    public keys(): Iterable<K> {\r\n        return this.record.map(([ key ])=> key);\r\n    }\r\n\r\n}\r\n\r\n\r\nexport const Polyfill: { new<K,V>(): LightMap<K,V> } = \r\n    typeof Map !== \"undefined\" ? Map : LightMapImpl;\r\n\r\n","\r\n\r\nimport { Polyfill as MapPolyfill } from \"./Map\";\r\n\r\nexport const Polyfill: { new<K extends object,V>(): WeakMap<K,V> } = \r\n    typeof WeakMap !== \"undefined\" ? WeakMap : MapPolyfill;\r\n\r\n"],"names":["exports","evt","asyncOp","out","importProxy_1","Evt","create","undefined","currentCallCount","attach","data","thisCallCount","prOpResult","opResult","_a","post","args","length","StatefulEvt","EventTargetLikeAsValue","fromImplForTargetEventLike","ctx","target","eventName","options","target_","proxy","canBe","evt_1","isCtxDone_1","getEvtDonePostCount","evtDoneOrAborted","postCount","n","then","mergeImpl","Array","from","map","HasEventTargetAddRemove","match","listener","addEventListener","removeEventListener","NodeStyleEventEmitter","addListener","removeListener","JQueryStyleEventEmitter","on","off","RxJSSubject","subscription_1","subscribe","unsubscribe","id","assert","attachOnce","fromImplForObserver","ObserverConstructor","observer","entry","_b","observe","disconnect","ctxOrTargetOrObserverConstructor","targetOrEventNameOrObserverConstructorOrObserverTarget","eventNameOrOptionsOrObserverTarget","typeGuard","ctxByObj","WeakMap_1","obj","get","Ctx","set","require","runSideEffect","sideEffect","CtxLikeAsValue","nsCtxLike","lazyEvtAttach","LazyEvt_1","lazyEvtDetach","__maxHandlers","traceId","handlers","handlerTriggers","Map_1","__currentChronologyMark","asyncHandlerCount","EvtImpl","this","__defaultMaxHandlers","isFinite","p1","p2","isP1Ctx","initialValue","callback","Object","params","formatter","log","traceFormatter","JSON","stringify","inputs","console","apply","__spreadArray","_d","op","invocableOp","invocableOpByOp","Error","join","handler","wTimer","rejectPr","index","indexOf","zz__removeHandler","splice","async","delete","safeClearTimeout","EvtError_1","resolvePr","once","detach","transformedData","prOrValue","call","isPromiseLike","propsFromArgs","propsFromMethodName","d","Deferred_1","detachHandler","reject","pr","timeout","safeSetTimeout","handlerTrigger","triggerHandler","isPending","resolve","asyncHandlerChronologyMark","getChronologyMark","prepend","i","extract","push","checkForPotentialMemoryLeak","zz__addHandler","onAddHandlerByEvt","has","maxHandlers","message","concat","getHandlers","Evt_parsePropsFromArgs_1","toString","keys","key","forEach","str","warn","hasSideEffect","getInvocableOp","isExtracted","find","_this_1","isHandledByOp","handlerCount","filter","prAllHandlerCallbacksResolved","getReturnValue","Promise","all","_c","prOrUndefined","runExclusive","buildMethodCb","postChronologyMark","releaseLock","chronologyMarkStartResolveTick","promises","handlerMark","exceptionRange","asyncHandlerChronologyExceptionRange","lowerMark","upperMark","promise","catch","handlersDump","detachedHandlers","evtDelegate","addHandler","__assign","parsePropsFromArgs","propsFormMethodNames","waitFor","Symbol","asyncIterator","iter","props","newCtx","self","previousDonePostCount","timerWrap","setTimeoutCallback","error","abort","timer","setTimeout","evtProxy","pipe","registerSideEffect","clearTimeout","events","event","type","timer_1","next","eventWrap","shift","dEventWrap_1","ctx2_1","attachOnceExtract","done","return","__attachX","attachExtract","attachPrepend","attachOncePrepend","methodName","isHandled","evtAttach","wait","trace","overwriteReadonlyProp","postSync","postAsync","postAsyncFactory","postOrPostAndWait","Evt_create_1","Evt_newCtx_1","Evt_merge_1","Evt_from_1","getCtxFactory","Evt_loosenType_1","Evt_factorize_1","Evt_asPostable_1","Evt_asyncPipe_1","Evt_asNonPostable_1","evts","evtUnion","matchAll","canBeOperator","p","defaultParams","getOpWrap","ops","compose_1","rest","value","p3","p4","initialPostCount","LazyEvt","__evt","doWait","__post","EventTargetLike","eventTarget","o","_super","setPrototypeOf","_newTarget","prototype","__extends","CtxLike","f_o_g","op1","op2","opAtoB","opBtoC","dataA","resultB","dataB","resultC","compose","op1_o_op2","__read","statefulFλOp","state","encapsulateOpState","statelessOpToStatelessFλ","msg","_this","stack","split","condition","arguments","assertIsRefWrapper_1","ref","AssertionError","x","errorMessage","is","name","toLowerCase","_value","propertyName","errorDefineProperty","propertyDescriptor","getOwnPropertyDescriptor","String","defineProperty","isMatched","resolve_","reject_","Deferred","ms","queuedCalls","isRunning","prComplete","ExecQueue","globalContext","clusters","getOrCreateExecQueue","context","groupRef","execQueueByGroup","execQueue","createGroupRef","buildFnPromise","runExclusiveFunction","classInstanceObject","getExecQueueByFunctionAndContext","cancelAllQueuedCalls","groupByRunExclusiveFunction","isGlobal","fun","onPrCompleteResolve","onComplete","result","reason","callee","buildFnCallback","pop","hasCallback","__spreadArrays","record","LightMapImpl","Map","WeakMap"],"sourceRoot":""}